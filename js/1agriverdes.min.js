$=jQuery;
jQuery(document).ready(function () {
   styleCookiesAdvice()
   isCookiesBarActive()
});

/**
 * Añade las clases y estructuras html necesarias para maquetar las cookies
 *
 */
function styleCookiesAdvice() {
	jQuery('#catapult-cookie-bar').addClass('cookies')
	jQuery('span.ctcc-left-side').addClass('col-lg-9 col-lg-offset-1 col-md-9 col-md-offset-1 col-sm-9 col-sm-offset-1 col-xs-9 col-xs-offset-1')
	jQuery('div.x_close').empty().addClass('col-lg-1 col-md-1 col-sm-1 col-xs-1 text-right').append('<img src="wp-content/themes/agriverdes/img/close.svg" id="cookies" class="cookies__close">')
	// jQuery('.x_close').on('click', function () {
	// 	//        jQuery('#catapult-cookie-bar').css("display", "none")
	// 	// jQuery('html').css("margin-top", "0");
	// })
}

function isCookiesBarActive() {
	if (jQuery('body').hasClass('has-cookie-bar') === false) {
		jQuery('#catapult-cookie-bar').hide()
		console.log('No tiene barra de cookies');
	}
}

/**
 * Formularios condicionales
 */
jQuery(document).ready(function () {


	/**
	 * Funcionalidad para los botones de ficheros
	 */

	// Javascript para que funcione el botón de subir los curriculum
	jQuery('#curriculum_btn').click(function () {
		jQuery('input[name="curriculum"]').trigger('click');
	})

	jQuery('input[name="curriculum"]').change(function () {
		jQuery('#curriculum_btn h5').text(this.value.replace(/C:\\fakepath\\/i, ''))
	})

	// Javascript para que funcione el botón de subir las fotos.
	jQuery('#foto_btn').click(function () {
		jQuery('input[name="foto"]').trigger('click');
	})

	jQuery('input[name="foto"]').change(function () {
		jQuery('#foto_btn h5').text(this.value.replace(/C:\\fakepath\\/i, ''))
	})


	/**
	 * FORMULARRIO BUSCO TRABAJADORES
	 */

	/*
	 * Cuando se seleccione la opción "Encargado"
	 */
	jQuery('select[name=cultivo]').change(function () {
		if (jQuery(this).val() === 'Otro') {
			// Muestro el input de "Otro cultivo"
			jQuery('div.cultivo_libre').slideDown(300);
		} else {
			// Oculto el input de "Otro cultivo"
			jQuery('div.cultivo_libre').slideUp(300);
		}
	});

	/**
	 * FORMULARRIO BUSCO TRABAJO
	 */

	// Deshabilitamos el input de número de trabajadores
	jQuery('input[name=trabajadorescuadrilla]').attr('disabled', 'disabled');

	/*
	 * Cuando se marque la opción de trabajar en la oficina
	 */
	jQuery('input[name=trabajar]').change(function () {
		if (jQuery(this).is(":checked")) {
			if (jQuery(this).val() === jQuery('input[name=trabajar]').first().val()) {
				// Ocultar la opcion "Peon agricola" en el select "Puesto"
				jQuery('select[name=puesto]').children('option').eq(2).hide();

				// Oculto los inputs de agrarios en "Donde quieres trabjar"
				jQuery('#inputs-agrarios').slideUp(300, function () {
				// Muestro los inputs de oficina en "Donde quieres trabjar"
					jQuery('#inputs-oficina').slideDown(300);
				});
			} else {
				// Oculto los inputs de oficina en "Donde quieres trabjar"
				jQuery('#inputs-oficina').slideUp(300, function () {
					// Muestro los inputs de agrarios en "Donde quieres trabjar"
					jQuery('#inputs-agrarios').slideDown(300);
				});

				// Mostrar la opcion "Peon agricola" en el select "Puesto"
				jQuery('select[name=puesto]').children('option').eq(2).show();
			}
		}
	});

	/*
	 * Cuando se seleccione la opción "Encargado"
	 */
	jQuery('select[name=puesto]').change(function () {
		if (jQuery(this).val() == jQuery(this).children('option').last().val()) {
			// Mostrar los inputs de cuadrilla
			jQuery('div.cuadrilla').slideDown(300);
			jQuery('div.trabajadorescuadrilla').slideDown(300);
		} else {
			// Ocultar los inputs de cuadrilla
			jQuery('div.cuadrilla').slideUp(300);
			jQuery('div.trabajadorescuadrilla').slideUp(300);
		}
	});

	/*
	 * Cuando se marque la casilla de "Dispongo de cuadrilla"
	 */
	jQuery('div.cuadrilla input').change(function () {
		if (jQuery(this).is(":checked")) {
			jQuery('input[name=trabajadorescuadrilla]').removeAttr('disabled');
		}

		if (jQuery(this).is(':not(:checked)')) {
			jQuery('input[name=trabajadorescuadrilla]').attr('disabled', 'disabled');
		}
	});
});

var PROGRAMMATIC_SCROLLING = false;
var CLICKED_HREF_SCROLL = '';
            // Esto sería para que funcionara a unos pixeles concretos. En este caso a 500.

/*jQuery(function() {
    var full_img = jQuery(".full_img");
    jQuery(window).scroll(function() {    
        var scroll = jQuery(window).scrollTop();
        var thisTop = jQuery(this).offset().top;
        var thisBot = thisTop + jQuery(this).height();
    
        if (scroll >= 500) {
            full_img.addClass("full_img--scrolled");
        } else {
            full_img.removeClass("full_img--scrolled");
        }
    });
})
*/
        // Esto es para que funcione cuando la caja toque el viewport bottom.


jQuery(function() {
  jQuery(window).scroll(function() {


    var $window = jQuery(window);
    var viewportTop = $window.scrollTop()-90;
    var viewportBottom = viewportTop + $window.height();
      
    jQuery('.full_img').each(function(){
      var thisTop = jQuery(this).offset().top;
      var thisBot = thisTop + jQuery(this).height();

      if (thisBot <= viewportBottom){
        jQuery(this).addClass('full_img--scrolled');
      }
        
      if (thisBot >= viewportBottom){
        jQuery(this).removeClass('full_img--scrolled');
      }

    });
});

});

jQuery(document).ready(function () {

    /**
     * Función para deshabilitar en menú
     * 
     * @returns void
     */
    function disableMenu() {
        var $menuToggle = jQuery('#hamb_01');
        var $menuWrap = jQuery('.menu');
        var $menuOverlay = $menuWrap.find('.menu_ol');
        var $menuCol = $menuWrap.find('.menu__col');

        $menuToggle.removeClass('open');

        // Desactivamos el menu
        $menuCol.removeClass("menu__col--open");
        // Desactivamos el background del menu
        $menuOverlay.fadeToggle(500, function() {
            $menuWrap.css('display', 'none')
        });
    }

    /**
     * Devuelve el último componente de nombre de una ruta
     * 
     * @param string path Una ruta 
     * @returns string Devuelve el nombre base de path
     */
    function baseName(path)
    {
        var base = new String(path).substring(path.lastIndexOf('/') + 1);

        if (base.lastIndexOf(".") != -1) {
            base = base.substring(0, base.lastIndexOf("."));
        }
        return base;
    }


    /**
     * Programatically scroll to a DOM element
     */
     function runProgScroll(scrollPosition, toggleId) {
        PROGRAMMATIC_SCROLLING = true;
        if (toggleId) {
            CLICKED_HREF_SCROLL = toggleId;
        }

        jQuery('html, body').stop().animate({
            scrollTop: scrollPosition
        }).promise().then(function() {
            PROGRAMMATIC_SCROLLING = false;
        })
     }

    /*
     * Clic sobre el boton "Busco trabajadores"
     */
    jQuery('#trabajadores-btn').on('click', function () {
        if (!jQuery(this).hasClass('-active')) {

            var url = jQuery(this).data('url');

            if (url !== '') {
                window.location.href = url;
            } else {
                jQuery(this).addClass('-active');
                runProgScroll(jQuery('#trabajadores').offset().top - jQuery('#header').height(), 'trabajadores-btn');
                disableMenu();
            }
        }
    });

    /*
     * Clic sobre el boton "Busco trabajo"
     */
    jQuery('#trabajo-btn').on('click', function () {
        if (!jQuery(this).hasClass('-active')) {
            
            var url = jQuery(this).data('url');

            if (url !== '') {
                window.location.href = url;
            } else {
                jQuery(this).addClass('-active');
                runProgScroll(jQuery('#trabajo').offset().top - jQuery('#header').height(), 'trabajo-btn');
                disableMenu();
            }
        }
    });

    /*
     * Clic sobre el boton de la flecha
     */
    jQuery('.footer__back').on('click', function () {
        runProgScroll(0)
    });

    /*
     * Clic sobre el enlaces del menu
     */
    jQuery('.menu-item').on('click', function (event) {
        disableMenu();

        // Si los enlaces son en la misma pagina
        if (jQuery(this).hasClass('menu-item-anchor')) {
            event.preventDefault();
            var toScroll = baseName(jQuery(this).attr('href'));
            var scrollOptions = {
                scrollTop: jQuery(toScroll).offset().top - jQuery('#header').height()
                        //        }, 500, 'easeInOutQuint');
            };

            jQuery('html, body').stop().animate(scrollOptions, 1000, 'swing');
        }
    });
});

jQuery(document).ready(function () {
    var $menuToggle = jQuery('#hamb_01');
    var $menuWrap = jQuery('.menu');
    var $menuOverlay = $menuWrap.find('.menu_ol');
    var $menuCol = $menuWrap.find('.menu__col');
    var menuChangingState = false;

    // Al pinchar sobre el icono del menú
    $menuToggle.on('click', function () {
        if (!menuChangingState) {
            menuChangingState = true;
            var opening = !$menuWrap.is(':visible'); // If opening/closing the menu

            // If opening, display the menu wrap
            if (opening) {
                $menuWrap.css('display', 'block');
            }

            // Give DOM some time to think...
            setTimeout(function() {
                // Cambiamos el icono entre la "hamburguesa" y la X
                $menuToggle.toggleClass('open');

                // Activamos el menu
                $menuCol.toggleClass("menu__col--open");
                // Activamos el background del menu
                $menuOverlay.fadeToggle(500, function() {
                    // If closing, hide the menu wrap after fade animation
                    if (!opening) {
                        $menuWrap.css('display', 'none');
                    }
                    menuChangingState = false;
                });
            }, 0)
        }
    });

    // Al pinchar sobre la capa oscurecida del menu desplegado
    $menuOverlay.on('click', function () {
        // Cambiamos el icono entre la "hamburguesa" y la X
        $menuToggle.removeClass('open');

        // Desactivamos el menu
        $menuCol.removeClass("menu__col--open");
        // Desactivamos el background del menu
        jQuery(this).fadeToggle(500, function() {
            $menuWrap.css('display', 'none')
        });
    });
});

/*!
Waypoints - 4.0.1
Copyright © 2011-2016 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
!function(){"use strict";function t(n){if(!n)throw new Error("No options passed to Waypoint constructor");if(!n.element)throw new Error("No element option passed to Waypoint constructor");if(!n.handler)throw new Error("No handler option passed to Waypoint constructor");this.key="waypoint-"+e,this.options=t.Adapter.extend({},t.defaults,n),this.element=this.options.element,this.adapter=new t.Adapter(this.element),this.callback=n.handler,this.axis=this.options.horizontal?"horizontal":"vertical",this.enabled=this.options.enabled,this.triggerPoint=null,this.group=t.Group.findOrCreate({name:this.options.group,axis:this.axis}),this.context=t.Context.findOrCreateByElement(this.options.context),t.offsetAliases[this.options.offset]&&(this.options.offset=t.offsetAliases[this.options.offset]),this.group.add(this),this.context.add(this),i[this.key]=this,e+=1}var e=0,i={};t.prototype.queueTrigger=function(t){this.group.queueTrigger(this,t)},t.prototype.trigger=function(t){this.enabled&&this.callback&&this.callback.apply(this,t)},t.prototype.destroy=function(){this.context.remove(this),this.group.remove(this),delete i[this.key]},t.prototype.disable=function(){return this.enabled=!1,this},t.prototype.enable=function(){return this.context.refresh(),this.enabled=!0,this},t.prototype.next=function(){return this.group.next(this)},t.prototype.previous=function(){return this.group.previous(this)},t.invokeAll=function(t){var e=[];for(var n in i)e.push(i[n]);for(var o=0,r=e.length;r>o;o++)e[o][t]()},t.destroyAll=function(){t.invokeAll("destroy")},t.disableAll=function(){t.invokeAll("disable")},t.enableAll=function(){t.Context.refreshAll();for(var e in i)i[e].enabled=!0;return this},t.refreshAll=function(){t.Context.refreshAll()},t.viewportHeight=function(){return window.innerHeight||document.documentElement.clientHeight},t.viewportWidth=function(){return document.documentElement.clientWidth},t.adapters=[],t.defaults={context:window,continuous:!0,enabled:!0,group:"default",horizontal:!1,offset:0},t.offsetAliases={"bottom-in-view":function(){return this.context.innerHeight()-this.adapter.outerHeight()},"right-in-view":function(){return this.context.innerWidth()-this.adapter.outerWidth()}},window.Waypoint=t}(),function(){"use strict";function t(t){window.setTimeout(t,1e3/60)}function e(t){this.element=t,this.Adapter=o.Adapter,this.adapter=new this.Adapter(t),this.key="waypoint-context-"+i,this.didScroll=!1,this.didResize=!1,this.oldScroll={x:this.adapter.scrollLeft(),y:this.adapter.scrollTop()},this.waypoints={vertical:{},horizontal:{}},t.waypointContextKey=this.key,n[t.waypointContextKey]=this,i+=1,o.windowContext||(o.windowContext=!0,o.windowContext=new e(window)),this.createThrottledScrollHandler(),this.createThrottledResizeHandler()}var i=0,n={},o=window.Waypoint,r=window.onload;e.prototype.add=function(t){var e=t.options.horizontal?"horizontal":"vertical";this.waypoints[e][t.key]=t,this.refresh()},e.prototype.checkEmpty=function(){var t=this.Adapter.isEmptyObject(this.waypoints.horizontal),e=this.Adapter.isEmptyObject(this.waypoints.vertical),i=this.element==this.element.window;t&&e&&!i&&(this.adapter.off(".waypoints"),delete n[this.key])},e.prototype.createThrottledResizeHandler=function(){function t(){e.handleResize(),e.didResize=!1}var e=this;this.adapter.on("resize.waypoints",function(){e.didResize||(e.didResize=!0,o.requestAnimationFrame(t))})},e.prototype.createThrottledScrollHandler=function(){function t(){e.handleScroll(),e.didScroll=!1}var e=this;this.adapter.on("scroll.waypoints",function(){(!e.didScroll||o.isTouch)&&(e.didScroll=!0,o.requestAnimationFrame(t))})},e.prototype.handleResize=function(){o.Context.refreshAll()},e.prototype.handleScroll=function(){var t={},e={horizontal:{newScroll:this.adapter.scrollLeft(),oldScroll:this.oldScroll.x,forward:"right",backward:"left"},vertical:{newScroll:this.adapter.scrollTop(),oldScroll:this.oldScroll.y,forward:"down",backward:"up"}};for(var i in e){var n=e[i],o=n.newScroll>n.oldScroll,r=o?n.forward:n.backward;for(var s in this.waypoints[i]){var l=this.waypoints[i][s];if(null!==l.triggerPoint){var a=n.oldScroll<l.triggerPoint,h=n.newScroll>=l.triggerPoint,p=a&&h,u=!a&&!h;(p||u)&&(l.queueTrigger(r),t[l.group.id]=l.group)}}}for(var d in t)t[d].flushTriggers();this.oldScroll={x:e.horizontal.newScroll,y:e.vertical.newScroll}},e.prototype.innerHeight=function(){return this.element==this.element.window?o.viewportHeight():this.adapter.innerHeight()},e.prototype.remove=function(t){delete this.waypoints[t.axis][t.key],this.checkEmpty()},e.prototype.innerWidth=function(){return this.element==this.element.window?o.viewportWidth():this.adapter.innerWidth()},e.prototype.destroy=function(){var t=[];for(var e in this.waypoints)for(var i in this.waypoints[e])t.push(this.waypoints[e][i]);for(var n=0,o=t.length;o>n;n++)t[n].destroy()},e.prototype.refresh=function(){var t,e=this.element==this.element.window,i=e?void 0:this.adapter.offset(),n={};this.handleScroll(),t={horizontal:{contextOffset:e?0:i.left,contextScroll:e?0:this.oldScroll.x,contextDimension:this.innerWidth(),oldScroll:this.oldScroll.x,forward:"right",backward:"left",offsetProp:"left"},vertical:{contextOffset:e?0:i.top,contextScroll:e?0:this.oldScroll.y,contextDimension:this.innerHeight(),oldScroll:this.oldScroll.y,forward:"down",backward:"up",offsetProp:"top"}};for(var r in t){var s=t[r];for(var l in this.waypoints[r]){var a,h,p,u,d,f=this.waypoints[r][l],c=f.options.offset,w=f.triggerPoint,y=0,g=null==w;f.element!==f.element.window&&(y=f.adapter.offset()[s.offsetProp]),"function"==typeof c?c=c.apply(f):"string"==typeof c&&(c=parseFloat(c),f.options.offset.indexOf("%")>-1&&(c=Math.ceil(s.contextDimension*c/100))),a=s.contextScroll-s.contextOffset,f.triggerPoint=Math.floor(y+a-c),h=w<s.oldScroll,p=f.triggerPoint>=s.oldScroll,u=h&&p,d=!h&&!p,!g&&u?(f.queueTrigger(s.backward),n[f.group.id]=f.group):!g&&d?(f.queueTrigger(s.forward),n[f.group.id]=f.group):g&&s.oldScroll>=f.triggerPoint&&(f.queueTrigger(s.forward),n[f.group.id]=f.group)}}return o.requestAnimationFrame(function(){for(var t in n)n[t].flushTriggers()}),this},e.findOrCreateByElement=function(t){return e.findByElement(t)||new e(t)},e.refreshAll=function(){for(var t in n)n[t].refresh()},e.findByElement=function(t){return n[t.waypointContextKey]},window.onload=function(){r&&r(),e.refreshAll()},o.requestAnimationFrame=function(e){var i=window.requestAnimationFrame||window.mozRequestAnimationFrame||window.webkitRequestAnimationFrame||t;i.call(window,e)},o.Context=e}(),function(){"use strict";function t(t,e){return t.triggerPoint-e.triggerPoint}function e(t,e){return e.triggerPoint-t.triggerPoint}function i(t){this.name=t.name,this.axis=t.axis,this.id=this.name+"-"+this.axis,this.waypoints=[],this.clearTriggerQueues(),n[this.axis][this.name]=this}var n={vertical:{},horizontal:{}},o=window.Waypoint;i.prototype.add=function(t){this.waypoints.push(t)},i.prototype.clearTriggerQueues=function(){this.triggerQueues={up:[],down:[],left:[],right:[]}},i.prototype.flushTriggers=function(){for(var i in this.triggerQueues){var n=this.triggerQueues[i],o="up"===i||"left"===i;n.sort(o?e:t);for(var r=0,s=n.length;s>r;r+=1){var l=n[r];(l.options.continuous||r===n.length-1)&&l.trigger([i])}}this.clearTriggerQueues()},i.prototype.next=function(e){this.waypoints.sort(t);var i=o.Adapter.inArray(e,this.waypoints),n=i===this.waypoints.length-1;return n?null:this.waypoints[i+1]},i.prototype.previous=function(e){this.waypoints.sort(t);var i=o.Adapter.inArray(e,this.waypoints);return i?this.waypoints[i-1]:null},i.prototype.queueTrigger=function(t,e){this.triggerQueues[e].push(t)},i.prototype.remove=function(t){var e=o.Adapter.inArray(t,this.waypoints);e>-1&&this.waypoints.splice(e,1)},i.prototype.first=function(){return this.waypoints[0]},i.prototype.last=function(){return this.waypoints[this.waypoints.length-1]},i.findOrCreate=function(t){return n[t.axis][t.name]||new i(t)},o.Group=i}(),function(){"use strict";function t(t){return t===t.window}function e(e){return t(e)?e:e.defaultView}function i(t){this.element=t,this.handlers={}}var n=window.Waypoint;i.prototype.innerHeight=function(){var e=t(this.element);return e?this.element.innerHeight:this.element.clientHeight},i.prototype.innerWidth=function(){var e=t(this.element);return e?this.element.innerWidth:this.element.clientWidth},i.prototype.off=function(t,e){function i(t,e,i){for(var n=0,o=e.length-1;o>n;n++){var r=e[n];i&&i!==r||t.removeEventListener(r)}}var n=t.split("."),o=n[0],r=n[1],s=this.element;if(r&&this.handlers[r]&&o)i(s,this.handlers[r][o],e),this.handlers[r][o]=[];else if(o)for(var l in this.handlers)i(s,this.handlers[l][o]||[],e),this.handlers[l][o]=[];else if(r&&this.handlers[r]){for(var a in this.handlers[r])i(s,this.handlers[r][a],e);this.handlers[r]={}}},i.prototype.offset=function(){if(!this.element.ownerDocument)return null;var t=this.element.ownerDocument.documentElement,i=e(this.element.ownerDocument),n={top:0,left:0};return this.element.getBoundingClientRect&&(n=this.element.getBoundingClientRect()),{top:n.top+i.pageYOffset-t.clientTop,left:n.left+i.pageXOffset-t.clientLeft}},i.prototype.on=function(t,e){var i=t.split("."),n=i[0],o=i[1]||"__default",r=this.handlers[o]=this.handlers[o]||{},s=r[n]=r[n]||[];s.push(e),this.element.addEventListener(n,e)},i.prototype.outerHeight=function(e){var i,n=this.innerHeight();return e&&!t(this.element)&&(i=window.getComputedStyle(this.element),n+=parseInt(i.marginTop,10),n+=parseInt(i.marginBottom,10)),n},i.prototype.outerWidth=function(e){var i,n=this.innerWidth();return e&&!t(this.element)&&(i=window.getComputedStyle(this.element),n+=parseInt(i.marginLeft,10),n+=parseInt(i.marginRight,10)),n},i.prototype.scrollLeft=function(){var t=e(this.element);return t?t.pageXOffset:this.element.scrollLeft},i.prototype.scrollTop=function(){var t=e(this.element);return t?t.pageYOffset:this.element.scrollTop},i.extend=function(){function t(t,e){if("object"==typeof t&&"object"==typeof e)for(var i in e)e.hasOwnProperty(i)&&(t[i]=e[i]);return t}for(var e=Array.prototype.slice.call(arguments),i=1,n=e.length;n>i;i++)t(e[0],e[i]);return e[0]},i.inArray=function(t,e,i){return null==e?-1:e.indexOf(t,i)},i.isEmptyObject=function(t){for(var e in t)return!1;return!0},n.adapters.push({name:"noframework",Adapter:i}),n.Adapter=i}();
// ***
// sticky.js
//
// Sets fixed state on elements and handles their overflow scroll (locking the body's scroll whilst doing so).
//
// Steps:
// 1. Add `.sticky-parent` class to the parent element
// 2. Add `.sticky-element` class to the element we want to apply the sticky functionality to
//
// Optional:
// * Add `data-related-element-id` data-attribute to `.sticky-element` to toggle an `-active`
//   class on it whilst the sticky is fixed
//
// * Add `data-sticky-breakpoint` data-attribute to `.sticky-parent` to set a threshold for at
//   what breakpoint the sticky functionality should be disabled
//
// @breadadams
// ***

jQuery(window).load(function () {

  var stickyParents = document.querySelectorAll('.sticky-parent'); // .sticky-parent elements
  var headerHeight = jQuery('#header').outerHeight(); // Fixed header height
  var unstickStickyEvent = new CustomEvent('unstickSticky'); // Event to unstick a sticky element

  // If any stickyParents exist
  if (stickyParents.length) {

    // Loop over stickyParents
    jQuery(stickyParents).each(function(index, stickyParent) {
      var stickyElement = stickyParent.querySelector('.sticky-element'); // Get the stickyElement
      var stickyBreakpoint = stickyParent.dataset.stickyBreakpoint;

      // If stickyElement exists
      if (stickyElement !== null) {
        var stickyElement_Height = jQuery(stickyElement).outerHeight(true), // stickyElement's height
            stickyElementInner = stickyElement.querySelector('.sticky-element-inner'), // stickyElement inner element
            stickyElementRelatedId = stickyElement.dataset.relatedElementId,
            stickyElementRelatedActiveItem = document.getElementById(stickyElementRelatedId); // related element to toggle `-active` class on (eg. header buttons)

        // If stickyElementInner exists
        if (stickyElementInner !== null) {

          // stickyParentScrollStatus statuses
          var BEFORE = 'before',
              DURING = 'during',
              AFTER = 'after';

          var stickyParentScrollStatus = ''; // 'before' | 'during' | 'after'

          // CSS positioning helper methods

          // Position absolute, "stuck to top"
          var stickyPosAbsTop = function(prog) {
            stickyElement.style.position = 'absolute';
            stickyElement.style.top = 0;
            stickyElement.style.removeProperty('bottom');
            if (prog === true) {
              unlockBodyScroll();
            }
          }
          // Position absolute, "stuck to bottom"
          var stickyPosAbsBottom = function(prog) {
            stickyElement.style.position = 'absolute';
            stickyElement.style.bottom = 0;
            stickyElement.style.removeProperty('top');
            if (prog === true) {
              unlockBodyScroll();
            }
          }
          // Position fixed, offset by headerHeight
          var stickyPosFixed = function(prog) {
            stickyElement.style.position = 'fixed';
            stickyElement.style.top = headerHeight+'px';
            stickyElement.style.removeProperty('bottom');
            if (prog === true) {
              unlockBodyScroll();
            }
          }

          // Set/unset active class on sticky's related item
          var updateRelatedItemClass = function(active) {
            if (stickyElementRelatedActiveItem !== null) {
              if (active === true) {
                stickyElementRelatedActiveItem.classList.add('-active');
              } else if (active === false) {
                stickyElementRelatedActiveItem.classList.remove('-active');
              }
            }
          }

          // Waypoint for when the top of StickyParent
          // hits the bottom of #header
          var waypoint_parentTouchTop = new Waypoint({
            element: stickyParent,
            handler: function(direction) {
              if (tallerThanViewport(stickyParent)) {
                if (direction === 'down') { // On scroll into parent
                  if (stickyParentScrollStatus !== DURING && !PROGRAMMATIC_SCROLLING) {
                    stickyPosFixed();
                    updateRelatedItemClass(true);
                    stickyParentScrollStatus = DURING;
                  } else if (PROGRAMMATIC_SCROLLING) {
                    if (CLICKED_HREF_SCROLL === stickyElementRelatedId) {
                      stickyPosFixed(true);
                      updateRelatedItemClass(true);
                    } else {
                      stickyPosAbsBottom(true);
                      updateRelatedItemClass(false);
                    }
                    stickyParentScrollStatus = DURING;
                  }
                } else if (direction === 'up') { // On scroll up out of parent
                  if (stickyParentScrollStatus !== BEFORE && !PROGRAMMATIC_SCROLLING) {
                    checkIfHasToScrollUp(stickyElement, stickyElementInner, stickyParent, function(keepFixed) {
                      var shouldKeepFixed = keepFixed !== undefined ? keepFixed : false;

                      if (!shouldKeepFixed) {
                        stickyPosAbsTop();
                        updateRelatedItemClass(false);
                        stickyParentScrollStatus = BEFORE;
                      }
                    })
                  } else if (PROGRAMMATIC_SCROLLING) {
                    stickyPosAbsTop(true);
                    updateRelatedItemClass(false);
                    stickyParentScrollStatus = BEFORE;
                  }
                }
              } else {
                stickyPosAbsTop();
              }
            },
            offset: headerHeight
          })

          // Waypoint for when bottom of stickyParent
          // hits the bottom of the viewport
          var waypoint_parentTouchBottom = new Waypoint({
            element: stickyParent,
            handler: function(direction) {
              if (tallerThanViewport(stickyParent)) {
                if (direction === 'down') { // On scroll past parent
                  if (stickyParentScrollStatus !== AFTER && !PROGRAMMATIC_SCROLLING) {
                    checkIfHasToScrollDown(stickyElement, stickyElementInner, stickyParent, function() {
                      stickyPosAbsBottom();
                      updateRelatedItemClass(false);
                      stickyParentScrollStatus = AFTER;
                    })
                  } else if (PROGRAMMATIC_SCROLLING) {
                    stickyPosAbsBottom(true);
                    updateRelatedItemClass(false);
                    stickyParentScrollStatus = AFTER;
                  }
                } else if (direction === 'up') { // On scroll up into parent
                  if (stickyParentScrollStatus !== DURING && !PROGRAMMATIC_SCROLLING) {
                    stickyPosFixed();
                    updateRelatedItemClass(true);
                    stickyParentScrollStatus = DURING;
                  } else if (PROGRAMMATIC_SCROLLING) {
                    if (CLICKED_HREF_SCROLL === stickyElementRelatedId) {
                      stickyPosFixed(true);
                      updateRelatedItemClass(true);
                    } else {
                      stickyPosAbsTop(true);
                      updateRelatedItemClass(false);
                    }
                    stickyParentScrollStatus = DURING;
                  }
                }
              } else {
                stickyPosAbsTop();
              }
            },
            offset: function() {
              // Subtract viewport height from the stickyParent height
              // and subtract *that* from the main top offset of stickyParent
              return -(this.element.clientHeight - Waypoint.viewportHeight())
            }
          })

          document.body.addEventListener('unstickSticky', function(e) {
            if (stickyParentScrollStatus === DURING) {
              stickyPosAbsTop(true);
              updateRelatedItemClass(false);
            }
          }, false);

          if (stickyElementRelatedActiveItem !== null) {
            stickyElementRelatedActiveItem.addEventListener('click', function() {
              document.body.dispatchEvent(unstickStickyEvent)
            }, false);
          }
        }
      }

      // Disable sticky as per its breakpoint setting
      if (stickyBreakpoint !== undefined) {
        var breakpointSize = Number(stickyBreakpoint);
        var screenWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0); // screen width on load
        var stickyEnabled = screenWidth > breakpointSize ? true : false;

        var stickysWaypoints = [waypoint_parentTouchTop, waypoint_parentTouchBottom]

        // If sticky is disabled on load, disable it
        if (!stickyEnabled) {
          unlockBodyScroll()
          disableMultipleWaypoints(stickysWaypoints)
        }

        var resizeTimeout;
        window.addEventListener('resize', function() {
          clearTimeout(resizeTimeout);
          resizeTimeout = setTimeout(function() {
            var screenWidth = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
            
            if (screenWidth <= breakpointSize && stickyEnabled) {
              unlockBodyScroll()
              disableMultipleWaypoints(stickysWaypoints)
              stickyEnabled = false
            } else if (screenWidth > breakpointSize && !stickyEnabled) {
              enableMultipleWaypoints(stickysWaypoints)
              stickyEnabled = true
            }
          }, 600);
        })
      }
    })

    // Window resize event
    // Executes 600ms after the last resize event,
    // to be sure it's ran after transitions finished
    var resizeTimeout;
    window.addEventListener('resize', function() {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(function() {
        Waypoint.refreshAll();
      }, 600);
    })
  }
});

// ***
// HELPER METHODS
// ***

// Check if element1 is taller than element2
var isTallerThan = function(element1, element2) {
  return jQuery(element1).outerHeight(true) > jQuery(element2).outerHeight(true);
}

// Return throttled function afer specified timeout length
var throttleFunction = function(ms, callback) {
  var tF;
  return function() {
    var self = this, args = arguments;
    clearTimeout(tF);
    tF = setTimeout(function() {
      callback.apply(self, args);
    }, ms);
  };
}

// Check if sticky element has more content to scroll down
var checkIfHasToScrollDown = function(stickyElement, stickyElementInner, stickyParent, callback) {

  // Returns TRUE if the stickyElement is scrolled right to the bottom
  var hasToScroll = function() {
    return stickyElement.scrollTop < (jQuery(stickyElementInner).outerHeight(true) - jQuery(stickyElement).outerHeight(true))
  }

  // If stickyElement has scroll overflow & isn't already scrolled
  if (isTallerThan(stickyElementInner, stickyElement) && hasToScroll()) {

    var lockedScrollPosition = jQuery(stickyParent).position().top + jQuery(stickyParent).outerHeight(true) - window.innerHeight; // Get the scroll-position of when stickyParent is touching bottom of viewport
    if (!PROGRAMMATIC_SCROLLING) {
      lockBodyScroll(lockedScrollPosition);
    }

    // Move down 1 pixel if at the very top,
    // a "hack" so that scrollTop in mousewheel
    // event is always more than 0 initially
    if (stickyElement.scrollTop === 0) {
      stickyElement.scrollTop += 1;
    }

    // Add wheel event listener
    jQuery(window).on('wheel', throttleFunction( 1, function(e) {
      e.stopPropagation();
      var normalizedScroll = normalizeWheel(e.originalEvent);
      var deltaScrollDistance = normalizedScroll.pixelY; // Distance scrolled on "this" scroll event

      // If there's still space to scroll down inside stickyElement and we're not at top
      if (hasToScroll() && (stickyElement.scrollTop > 0)) {
        stickyElement.scrollTop += deltaScrollDistance; // Update stickyElement scrollTop with delta scroll value
      } else if (!hasToScroll()) {
        unlockBodyScroll('down');
        return callback(); // Run the callback
      }
    }));

  } else {
    return callback(); // Run the callback
  }
}

// Check if sticky element has more content to scroll up
var checkIfHasToScrollUp = function(stickyElement, stickyElementInner, stickyParent, callback) {

  // Returns TRUE if the stickyElement is scrolled past 0
  var hasToScroll = function() {
    return stickyElement.scrollTop > 0
  }

  // If stickyElement has scroll overflow
  if (hasToScroll()) {

    var lockedScrollPosition = jQuery(stickyParent).position().top - jQuery('#header').outerHeight(true); // Get the top position of stickyParent
    if (!PROGRAMMATIC_SCROLLING) {
      lockBodyScroll(lockedScrollPosition);
    }

    // Move up 1 pixel if at the very bottom,
    // a "hack" so that scrollTop in mousewheel
    // event is never at the very bottom on init
    if (stickyElement.scrollTop === (jQuery(stickyElementInner).outerHeight(true) - jQuery(stickyElement).outerHeight(true))) {
      stickyElement.scrollTop -= 1;
    }

    // Add wheel event listener
    jQuery(window).on('wheel', throttleFunction( 1, function(e) {
      e.stopPropagation();
      var normalizedScroll = normalizeWheel(e.originalEvent);
      var deltaScrollDistance = normalizedScroll.pixelY; // Distance scrolled on "this" scroll event

      // If there's still space to scroll inside stickyElement and we're not at the bottom
      if (
        hasToScroll() &&
        (stickyElement.scrollTop < (jQuery(stickyElementInner).outerHeight(true) - jQuery(stickyElement).outerHeight(true)))
      ) {
        stickyElement.scrollTop += deltaScrollDistance; // Update stickyElement scrollTop with delta scroll value
      // Else if we're at the very bottom of the stickyElement's overflow
      } else if (stickyElement.scrollTop === (jQuery(stickyElementInner).outerHeight(true) - jQuery(stickyElement).outerHeight(true))) {
        unlockBodyScroll('up');
        return callback(true); // Run the callback
      } else if (!hasToScroll()) { // If none of the above conditionals are met, we're leaving fixed mode
        unlockBodyScroll('up');
        return callback(); // Run the callback
      }
    }));

  } else {
    return callback(); // Run the callback
  }
}

// Lock body scrolling
var lockBodyScroll = function(scrollPos) {
  if (scrollPos > 0) {
    Waypoint.disableAll();
    var cssTop = (scrollPos * -1) + 'px';
    document.body.style.overflowY = 'scroll';
    document.body.style.position = 'fixed';
    document.body.style.top = cssTop;
    Waypoint.enableAll();
  }
}

// Unlock body scrolling
var unlockBodyScroll = function(direction) {
  Waypoint.disableAll();
  var cssTop = parseInt(document.body.style.top);
  cssTop = cssTop < 0 ? cssTop * -1 : cssTop;
  document.body.style.removeProperty('position');
  document.body.style.removeProperty('overflow-y');
  document.body.style.removeProperty('top');
  jQuery(window).off('wheel');
  if (cssTop && direction) {
    jQuery(window).scrollTop(direction == 'up' ? cssTop + 1 : cssTop - 1);
  }
  Waypoint.enableAll();
}

// Check if a DOM element is taller than viewport height
var tallerThanViewport = function(elem) {
  return jQuery(elem).outerHeight(true) > (window.innerHeight - jQuery('#header').outerHeight(true));
}

// Run disable method on an array of waypoints
var disableMultipleWaypoints = function(waypoints) {
  jQuery.each(waypoints, function(i, waypoint) {
    waypoint.disable();
  })
}
// Run enable method on an array of waypoints
var enableMultipleWaypoints = function(waypoints) {
  jQuery.each(waypoints, function(i, waypoint) {
    waypoint.enable();
  })
}


// normalize scroll wheel events
// https://github.com/facebookarchive/fixed-data-table/blob/master/src/vendor_upstream/dom/normalizeWheel.js
// Reasonable defaults
var PIXEL_STEP  = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;

function normalizeWheel(/*object*/ event) /*object*/ {
  var sX = 0, sY = 0,       // spinX, spinY
      pX = 0, pY = 0;       // pixelX, pixelY

  // Legacy
  if ('detail'      in event) { sY = event.detail; }
  if ('wheelDelta'  in event) { sY = -event.wheelDelta / 120; }
  if ('wheelDeltaY' in event) { sY = -event.wheelDeltaY / 120; }
  if ('wheelDeltaX' in event) { sX = -event.wheelDeltaX / 120; }

  // side scrolling on FF with DOMMouseScroll
  if ( 'axis' in event && event.axis === event.HORIZONTAL_AXIS ) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in event) { pY = event.deltaY; }
  if ('deltaX' in event) { pX = event.deltaX; }

  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {          // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {                             // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  }

  // Fall-back if spin cannot be determined
  if (pX && !sX) { sX = (pX < 1) ? -1 : 1; }
  if (pY && !sY) { sY = (pY < 1) ? -1 : 1; }

  return { spinX  : sX,
           spinY  : sY,
           pixelX : pX,
           pixelY : pY };
}